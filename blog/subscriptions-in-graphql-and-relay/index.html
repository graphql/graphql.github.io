<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Subscriptions in GraphQL and Relay | GraphQL</title><meta name="viewport" content="width=640"/><meta name="description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:title" content="GraphQL: A query language for APIs."/><meta property="og:description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.org/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: A query language for APIs."/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" alt="GraphQL Logo" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">Learn</a><a href="/code/">Code</a><a href="/community/">Community</a><a href="https://graphql.github.io/graphql-spec/" target="_blank" rel="noopener noreferrer">Spec</a><a href="/codeofconduct/">Code of Conduct</a><a href="https://foundation.graphql.org/" target="_blank" rel="noopener noreferrer">Foundation</a><a href="https://l.graphql.org/" target="_blank" rel="noopener noreferrer">Landscape</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..." aria-label="Search docs"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>Subscriptions in GraphQL and Relay</h1><p>10/16/2015 by Dan Schafer and Laney Kuenzel</p><hr/><div><p>When we announced and open-sourced GraphQL and Relay this year, we described how they can be used to perform reads with queries, and to perform writes with mutations. However, oftentimes clients want to get pushed updates from the server when data they care about changes. To support that, we’ve introduced a third operation into the GraphQL specification: subscription.</p><h2><a class="anchor" name="event-based-subscriptions"></a>Event-based subscriptions <a class="hash-link" href="#event-based-subscriptions">#</a></h2><p>The approach that we’ve taken to subscriptions parallels that of mutations; just as the list of mutations that the server supports describes all of the actions that a client can take, the list of subscriptions that the server supports describes all of the events that it can subscribe to. Just as a client can tell the server what data to refetch after it performs a mutation with a GraphQL selection, the client can tell the server what data it wants to be pushed with the subscription with a GraphQL selection.</p><p>For example, in the Facebook schema, we have a mutation field named <code>storyLike</code>, that clients can use to like a post. The client might want to refetch the like count, as well as the like sentence (“Dan and 3 others like this”. We do this translation on the server because of the complexity of that translation in various languages). To do so, they would issue the following mutation:</p><pre class="prism language-undefined">mutation <span class="function">StoryLikeMutation</span><span class="punctuation">(</span>$input<span class="punctuation">:</span> StoryLikeInput<span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="function">storyLike</span><span class="punctuation">(</span>input<span class="punctuation">:</span> $input<span class="punctuation">)</span> <span class="punctuation">{</span>
    story <span class="punctuation">{</span>
      likers <span class="punctuation">{</span> count <span class="punctuation">}</span>
      likeSentence <span class="punctuation">{</span> text <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>But when you’re looking at a post, you also want to get pushed an update whenever someone else likes the post! That’s where subscriptions come in; the Facebook schema has a subscription field named <code>storyLikeSubscribe</code> that allows the client to get pushed data anytime someone likes or unlikes that story! The client would create a subscription like this:</p><pre class="prism language-undefined">subscription <span class="function">StoryLikeSubscription</span><span class="punctuation">(</span>$input<span class="punctuation">:</span> StoryLikeSubscribeInput<span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="function">storyLikeSubscribe</span><span class="punctuation">(</span>input<span class="punctuation">:</span> $input<span class="punctuation">)</span> <span class="punctuation">{</span>
    story <span class="punctuation">{</span>
      likers <span class="punctuation">{</span> count <span class="punctuation">}</span>
      likeSentence <span class="punctuation">{</span> text <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>The client would then send this subscription to the server, along with the value for the <code>$input</code> variable, which would contain information like the story ID to which we are subscribing:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">input</span> StoryLikeSubscribeInput <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">storyId</span><span class="punctuation">:</span> <span class="type-name">string</span>
  <span class="attr-name">clientSubscriptionId</span><span class="punctuation">:</span> <span class="type-name">string</span>
<span class="punctuation">}</span></span></span></pre><p>At Facebook, we send this query to the server at build time to generate a unique ID for it, then subscribe to a special MQTT topic with the subscription ID in it, but many different subscription mechanisms could be used here.</p><p>On the server, we then trigger this subscription every time someone likes a post. If all of our clients were using GraphQL, we could put this hook in the GraphQL mutation; since we have non-GraphQL clients as well, we put the hook in a layer below the GraphQL mutation to ensure it always fires.</p><h2><a class="anchor" name="why-not-live-queries"></a>Why not Live Queries? <a class="hash-link" href="#why-not-live-queries">#</a></h2><p>Notably, this approach requires the client to subscribe to events that it cares about. Another approach is to have the client subscribe to a query, and ask for updates every time the result of that query changes. Why didn’t we take that approach?</p><p>Let’s look back at the data we wanted to refetch for the story:</p><pre class="prism language-undefined">fragment StoryLikeData on Story <span class="punctuation">{</span>
  story <span class="punctuation">{</span>
    likers <span class="punctuation">{</span> count <span class="punctuation">}</span>
    likeSentence <span class="punctuation">{</span> text <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>What events could trigger that a change to the data fetched in that fragment?</p><ul><li>Someone likes the post.</li><li>Someone unlikes the post.</li><li>Someone who had liked the post deactivates their account (changes the like count down one, changes the like sentence to decrement the translated count).</li><li>Someone who had liked the post reactivates their account (changes the like count up one, changes the like sentence to increment the translated count).</li><li>Someone who had liked the post blocks you (cannot show them in the like sentence).</li><li>Someone who had liked the post changes their name (need to update the text of the like sentence).</li><li>Our internal ranking model for the ordering of names in the like sentence updates, and we should be listing a different person first (want to update the text of the like sentence).</li></ul><p>And that’s just the tip of the iceberg in terms of events; each of those events also becomes tricky when there are thousands of people subscribed, and millions of people who liked the post. Implementing live queries for this set of data proved to be immensely complicated.</p><p>When building event-based subscriptions, the problem of determining what should trigger an event is easy, since the event defines that explicitly. It also proved fairly straight-forward to implement atop existing message queue systems. For live queries, though, this appeared much harder. The value of our fields is determined by the result of their resolve function, and figuring out all of the things that could alter the result of that function was difficult. We could in theory have polled on the server to implement this, but that had efficiency and timeliness issues. Based on this, we decided to invest in the event-based subscription approach.</p><h2><a class="anchor" name="what-s-next"></a>What’s next? <a class="hash-link" href="#what-s-next">#</a></h2><p>We’re actively building out the event-based subscription approach described above. We’ve built out live liking and commenting features on our iOS and Android apps using that approach, and are continuing to flesh out its functionality and API. While its current implementation at Facebook is coupled to Facebook’s infrastructure, we’re certainly looking forward to open sourcing our progress here as soon as we can.</p><p>Because our backend and schema don’t offer easy support for live queries, we don’t have any plans to develop them at Facebook. At the same time, it’s clear that there are backends and schemas for which live queries are feasible, and that they offer a lot of value in those situations. The discussion in the community on this topic has been fantastic, and we’re excited to see what kind of live query proposals emerge from it!</p><p>Subscriptions create a ton of possibilities for creating truly dynamic applications. We’re excited to continue developing GraphQL and Relay with the help of the community to enable these possibilities.</p></div></div><div class="nav-docs"><div class="nav-docs-section"><h3>Subscribe</h3><a rel="home" type="application/rss+xml" href="/blog/rss.xml">RSS</a></div><div class="nav-docs-section"><h3>Recent Posts</h3><ul><li><a href="/blog/production-ready/">Leaving technical preview</a></li><li><a href="/blog/rest-api-graphql-wrapper/">Wrapping a REST API in GraphQL</a></li><li><a href="/blog/mocking-with-graphql/">Mocking your server is easy with GraphQL</a></li><li>Subscriptions in GraphQL and Relay</li><li><a href="/blog/graphql-a-query-language/">GraphQL: A data query language</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home" aria-label="Homepage"></a><div><h5><a href="/learn/">Learn</a></h5><a href="/learn/">Introduction</a><a href="/learn/queries/">Query Language</a><a href="/learn/schema/">Type System</a><a href="/learn/execution/">Execution</a><a href="/learn/best-practices/">Best Practices</a></div><div><h5><a href="/code">Code</a></h5><a href="/code/#server-libraries">Servers</a><a href="/code/#graphql-clients">Clients</a><a href="/code/#tools">Tools</a></div><div><h5><a href="/community">Community</a></h5><a href="/community/upcoming-events/">Upcoming Events</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>More</h5><a href="https://graphql.github.io/graphql-spec/" target="_blank" rel="noopener noreferrer">GraphQL Specification</a><a href="https://foundation.graphql.org/" target="_blank" rel="noopener noreferrer">GraphQL Foundation</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GraphQL GitHub</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/blog/20151016-subscriptions.md" target="_blank" rel="noopener noreferrer">Edit this page ✎</a></div></section><section class="copyright">Copyright © 2020 The GraphQL Foundation. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page. Linux is a registered trademark of Linus Torvalds. <a href="http://www.linuxfoundation.org/privacy">Privacy Policy</a> and <a href="http://www.linuxfoundation.org/terms">Terms of Use</a>.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script></body></html>