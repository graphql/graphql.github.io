<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Execution | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: A query language for APIs."/><meta property="og:description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.org/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: A query language for APIs."/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">Learn</a><a href="/code/">Code</a><a href="/community/">Community</a><a href="/blog/">Blog</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">Spec</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>Execution</h1><div><p>After being validated, a GraphQL query is executed by a GraphQL server which returns a result that mirrors the shape of the requested query, typically as JSON.</p><p>GraphQL cannot execute a query without a type system, let&#x27;s use an example type system to illustrate executing a query. This is a part of the same type system used throughout the examples in these articles:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Query <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">human</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="operator">!</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Human</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Human <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span>
  <span class="attr-name">starships</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Starship</span><span class="punctuation">]</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">enum</span> Episode <span class="fields"><span class="punctuation">{</span>
  NEWHOPE
  EMPIRE
  JEDI
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Starship <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>In order to describe what happens when a query is executed, let&#x27;s use an example to walk through.</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>You can think of each field in a GraphQL query as a function or method of the previous type which returns the next type. In fact, this is exactly how GraphQL works. Each field on each type is backed by a function called the <em>resolver</em> which is provided by the GraphQL server developer. When a field is executed, the corresponding <em>resolver</em> is called to produce the next value.</p><p>If a field produces a scalar value like a string or number, then the execution completes. However if a field produces an object value then the query will contain another selection of fields which apply to that object. This continues until scalar values are reached. GraphQL queries always end at scalar values.</p><h2><a class="anchor" name="root-fields-resolvers"></a>Root fields &amp; resolvers <a class="hash-link" href="#root-fields-resolvers">#</a></h2><p>At the top level of every GraphQL server is a type that represents all of the possible entry points into the GraphQL API, it&#x27;s often called the <em>Root</em> type or the <em>Query</em> type.</p><p>In this example, our Query type provides a field called <code>human</code> which accepts the argument <code>id</code>. The resolver function for this field likely accesses a database and then constructs and returns a <code>Human</code> object.</p><pre class="prism language-js">Query<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
      userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>This example is written in JavaScript, however GraphQL servers can be built in <a href="/code/">many different languages</a>. A resolver function receives three arguments:</p><ul><li><code>obj</code> The previous object, which for a field on the root Query type is often not used.</li><li><code>args</code> The arguments provided to the field in the GraphQL query.</li><li><code>context</code> A value which is provided to every resolver and holds important contextual information like the currently logged in user, or access to a database.</li></ul><h2><a class="anchor" name="asynchronous-resolvers"></a>Asynchronous resolvers <a class="hash-link" href="#asynchronous-resolvers">#</a></h2><p>Let&#x27;s take a closer look at what&#x27;s happening in this resolver function.</p><pre class="prism language-js"><span class="function">human</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
  <span class="keyword">return</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadHumanByID</span><span class="punctuation">(</span>args<span class="punctuation">.</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
    userData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Human</span><span class="punctuation">(</span>userData<span class="punctuation">)</span>
  <span class="punctuation">)</span>
<span class="punctuation">}</span></pre><p>The <code>context</code> is used to provide access to a database which is used to load the data for a user by the <code>id</code> provided as an argument in the GraphQL query. Since loading from a database is an asynchronous operation, this returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise</a>. In JavaScript Promises are used to work with asynchronous values, but the same concept exists in many languages, often called <em>Futures</em>, <em>Tasks</em> or <em>Deferred</em>. When the database returns, we can construct and return a new <code>Human</code> object.</p><p>Notice that while the resolver function needs to be aware of Promises, the GraphQL query does not. It simply expects the <code>human</code> field to return something which it can then ask the <code>name</code> of. During execution, GraphQL will wait for Promises, Futures, and Tasks to complete before continuing and will do so with optimal concurrency.</p><h2><a class="anchor" name="trivial-resolvers"></a>Trivial resolvers <a class="hash-link" href="#trivial-resolvers">#</a></h2><p>Now that a <code>Human</code> object is available, GraphQL execution can continue with the fields requested on it.</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">name</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>name
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>A GraphQL server is powered by a type system which is used to determine what to do next. Even before the <code>human</code> field returns anything, GraphQL knows that the next step will be to resolve fields on the <code>Human</code> type since the type system tells it that the <code>human</code> field will return a <code>Human</code>.</p><p>Resolving the name in this case is very straight-forward. The name resolver function is called and the <code>obj</code> argument is the <code>new Human</code> object returned from the previous field. In this case, we expect that Human object to have a <code>name</code> property which we can read and return directly.</p><p>In fact, many GraphQL libraries will let you omit resolvers this simple and will just assume that if a resolver isn&#x27;t provided for a field, that a property of the same name should be read and returned.</p><h2><a class="anchor" name="scalar-coercion"></a>Scalar coercion <a class="hash-link" href="#scalar-coercion">#</a></h2><p>While the <code>name</code> field is being resolved, the <code>appearsIn</code> and <code>starships</code> fields can be resolved concurrently. The <code>appearsIn</code> field could also have a trivial resolver, but let&#x27;s take a closer look:</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">appearsIn</span><span class="punctuation">(</span>obj<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>appearsIn <span spellcheck="true" class="comment">// returns [ 4, 5, 6 ]</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>Notice that our type system claims <code>appearsIn</code> will return Enum values with known values, however this function is returning numbers! Indeed if we look up at the result we&#x27;ll see that the appropriate Enum values are being returned. What&#x27;s going on?</p><p>This is an example of scalar coercion. The type system knows what to expect and will convert the values returned by a resolver function into something that upholds the API contract. In this case, there may be an Enum defined on our server which uses numbers like <code>4</code>, <code>5</code>, and <code>6</code> internally, but represents them as Enum values in the GraphQL type system.</p><h2><a class="anchor" name="list-resolvers"></a>List resolvers <a class="hash-link" href="#list-resolvers">#</a></h2><p>We&#x27;ve already seen a bit of what happens when a field returns a list of things with the <code>appearsIn</code> field above. It returned a <em>list</em> of enum values, and since that&#x27;s what the type system expected, each item in the list was coerced to the appropriate enum value. What happens when the <code>starships</code> field is resolved?</p><pre class="prism language-js">Human<span class="punctuation">:</span> <span class="punctuation">{</span>
  <span class="function">starships</span><span class="punctuation">(</span>obj<span class="punctuation">,</span> args<span class="punctuation">,</span> context<span class="punctuation">)</span> <span class="punctuation">{</span>
    <span class="keyword">return</span> obj<span class="punctuation">.</span>starshipIDs<span class="punctuation">.</span><span class="function">map</span><span class="punctuation">(</span>
      id <span class="operator">=</span><span class="operator">&gt;</span> context<span class="punctuation">.</span>db<span class="punctuation">.</span><span class="function">loadStarshipByID</span><span class="punctuation">(</span>id<span class="punctuation">)</span><span class="punctuation">.</span><span class="function">then</span><span class="punctuation">(</span>
        shipData <span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">new</span> <span class="class-name">Starship</span><span class="punctuation">(</span>shipData<span class="punctuation">)</span>
      <span class="punctuation">)</span>
    <span class="punctuation">)</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>The resolver for this field is not just returning a Promise, it&#x27;s returning a <em>list</em> of Promises. The <code>Human</code> object had a list of ids of the <code>Starships</code> they piloted, but we need to go load all of those ids to get real Starship objects.</p><p>GraphQL will wait for all of these Promises concurrently before continuing, and when left with a list of objects, it will concurrently continue yet again to load the <code>name</code> field on each of these items.</p><h2><a class="anchor" name="producing-the-result"></a>Producing the result <a class="hash-link" href="#producing-the-result">#</a></h2><p>As each field is resolved, the resulting value is placed into a key-value map with the field name (or alias) as the key and the resolved value as the value, this continues from the bottom leaf fields of the query all the way back up to the original field on the root Query type. Collectively these produce a structure that mirrors the original query which can then be sent (typically as JSON) to the client which requested it.</p><p>Let&#x27;s take one last look at the original query to see how all these resolving functions produce a result:</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div></div><a class="read-next" href="/learn/introspection"><span class="read-next-continue">Continue Reading →</span><span class="read-next-title">Introspection</span></a></div><div class="nav-docs"><div><h3>Learn</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">Introduction</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">Queries and Mutations</a><ul><li><a href="/learn/queries/#fields">Fields</a></li><li><a href="/learn/queries/#arguments">Arguments</a></li><li><a href="/learn/queries/#aliases">Aliases</a></li><li><a href="/learn/queries/#fragments">Fragments</a></li><li><a href="/learn/queries/#variables">Variables</a></li><li><a href="/learn/queries/#operation-name">Operation Name</a></li><li><a href="/learn/queries/#directives">Directives</a></li><li><a href="/learn/queries/#mutations">Mutations</a></li><li><a href="/learn/queries/#inline-fragments">Inline Fragments</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schemas and Types</a><ul><li><a href="/learn/schema/#type-system">Type System</a></li><li><a href="/learn/schema/#type-language">Type Language</a></li><li><a href="/learn/schema/#object-types-and-fields">Object Types and Fields</a></li><li><a href="/learn/schema/#arguments">Arguments</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">The Query and Mutation Types</a></li><li><a href="/learn/schema/#scalar-types">Scalar Types</a></li><li><a href="/learn/schema/#enumeration-types">Enumeration Types</a></li><li><a href="/learn/schema/#lists-and-non-null">Lists and Non-Null</a></li><li><a href="/learn/schema/#interfaces">Interfaces</a></li><li><a href="/learn/schema/#union-types">Union Types</a></li><li><a href="/learn/schema/#input-types">Input Types</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">Validation</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">Execution</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">Introspection</a></li></ul></div><div><h3>Best Practices</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">Introduction</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">Thinking in Graphs</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">Serving over HTTP</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">Authorization</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">Pagination</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">Caching</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">Learn</a></h5><a href="/learn/">Introduction</a><a href="/learn/queries/">Query Language</a><a href="/learn/schema/">Type System</a><a href="/learn/execution/">Execution</a><a href="/learn/best-practices/">Best Practices</a></div><div><h5><a href="/code">Code</a></h5><a href="/code/#graphql-server-libraries">Servers</a><a href="/code/#graphql-clients">Clients</a><a href="/code/#tools">Tools</a></div><div><h5><a href="/community">Community</a></h5><a href="/community/upcoming-events/">Upcoming Events</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>More</h5><a href="/blog">GraphQL Team Blog</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">Read the Spec</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GitHub</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/Learn-Execution.md" target="_blank" rel="noopener noreferrer">Edit this page ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2016 Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.36a3412c4d5e820c895d.js"></script></body></html>