<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Pagination | GraphQL</title><meta name="viewport" content="width=640"/><meta name="description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:title" content="GraphQL: A query language for APIs."/><meta property="og:description" content="GraphQL provides a complete description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql.org/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: A query language for APIs."/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" alt="GraphQL Logo" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">Learn</a><a href="/code/">Code</a><a href="/community/">Community</a><a href="https://graphql.github.io/graphql-spec/" target="_blank" rel="noopener noreferrer">Spec</a><a href="/codeofconduct/">Code of Conduct</a><a href="https://foundation.graphql.org/" target="_blank" rel="noopener noreferrer">Foundation</a><a href="https://l.graphql.org/" target="_blank" rel="noopener noreferrer">Landscape</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..." aria-label="Search docs"/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>Pagination</h1><div><blockquote><p>Different pagination models enable different client capabilities</p></blockquote><p>A common use case in GraphQL is traversing the relationship between sets of objects. There are a number of different ways that these relationships can be exposed in GraphQL, giving a varying set of capabilities to the client developer.</p><h2><a class="anchor" name="plurals"></a>Plurals <a class="hash-link" href="#plurals">#</a></h2><p>The simplest way to expose a connection between objects is with a field that returns a plural type. For example, if we wanted to get a list of R2-D2&#x27;s friends, we could just ask for all of them:</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><h2><a class="anchor" name="slicing"></a>Slicing <a class="hash-link" href="#slicing">#</a></h2><p>Quickly, though, we realize that there are additional behaviors a client might want. A client might want to be able to specify how many friends they want to fetch; maybe they only want the first two. So we&#x27;d want to expose something like:</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      name
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>But if we just fetched the first two, we might want to paginate through the list as well; once the client fetches the first two friends, they might want to send a second request to ask for the next two friends. How can we enable that behavior?</p><h2><a class="anchor" name="pagination-and-edges"></a>Pagination and Edges <a class="hash-link" href="#pagination-and-edges">#</a></h2><p>There are a number of ways we could do pagination:</p><ul><li>We could do something like <code>friends(first:2 offset:2)</code> to ask for the next two in the list.</li><li>We could do something like <code>friends(first:2 after:$friendId)</code>, to ask for the next two after the last friend we fetched.</li><li>We could do something like <code>friends(first:2 after:$friendCursor)</code>, where we get a cursor from the last item and use that to paginate.</li></ul><p>In general, we&#x27;ve found that <strong>cursor-based pagination</strong> is the most powerful of those designed. Especially if the cursors are opaque, either offset or ID-based pagination can be implemented using cursor-based pagination (by making the cursor the offset or the ID), and using cursors gives additional flexibility if the pagination model changes in the future. As a reminder that the cursors are opaque and that their format should not be relied upon, we suggest base64 encoding them.</p><p>That leads us to a problem; though; how do we get the cursor from the object? We wouldn&#x27;t want cursor to live on the <code>User</code> type; it&#x27;s a property of the connection, not of the object. So we might want to introduce a new layer of indirection; our <code>friends</code> field should give us a list of edges, and an edge has both a cursor and the underlying node:</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>The concept of an edge also proves useful if there is information that is specific to the edge, rather than to one of the objects. For example, if we wanted to expose &quot;friendship time&quot; in the API, having it live on the edge is a natural place to put it.</p><h2><a class="anchor" name="end-of-list-counts-and-connections"></a>End-of-list, counts, and Connections <a class="hash-link" href="#end-of-list-counts-and-connections">#</a></h2><p>Now we have the ability to paginate through the connection using cursors, but how do we know when we reach the end of the connection? We have to keep querying until we get an empty list back, but we&#x27;d really like for the connection to tell us when we&#x27;ve reached the end so we don&#x27;t need that additional request. Similarly, what if we want to know additional information about the connection itself; for example, how many total friends does R2-D2 have?</p><p>To solve both of these problems, our <code>friends</code> field can return a connection object. The connection object will then have a field for the edges, as well as other information (like total count and information about whether a next page exists). So our final query might look more like:</p><pre class="prism language-graphql"><span class="punctuation">{</span>
  hero <span class="punctuation">{</span>
    name
    friends<span class="punctuation">(</span><span class="attr-name">first</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">)</span> <span class="punctuation">{</span>
      totalCount
      edges <span class="punctuation">{</span>
        node <span class="punctuation">{</span>
          name
        <span class="punctuation">}</span>
        cursor
      <span class="punctuation">}</span>
      pageInfo <span class="punctuation">{</span>
        endCursor
        hasNextPage
      <span class="punctuation">}</span>
    <span class="punctuation">}</span>
  <span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>Note that we also might include <code>endCursor</code> and <code>startCursor</code> in this <code>PageInfo</code> object. This way, if we don&#x27;t need any of the additional information that the edge contains, we don&#x27;t need to query for the edges at all, since we got the cursors needed for pagination from <code>pageInfo</code>. This leads to a potential usability improvement for connections; instead of just exposing the <code>edges</code> list, we could also expose a dedicated list of just the nodes, to avoid a layer of indirection.</p><h2><a class="anchor" name="complete-connection-model"></a>Complete Connection Model <a class="hash-link" href="#complete-connection-model">#</a></h2><p>Clearly, this is more complex than our original design of just having a plural! But by adopting this design, we&#x27;ve unlocked a number of capabilities for the client:</p><ul><li>The ability to paginate through the list.</li><li>The ability to ask for information about the connection itself, like <code>totalCount</code> or <code>pageInfo</code>.</li><li>The ability to ask for information about the edge itself, like <code>cursor</code> or <code>friendshipTime</code>.</li><li>The ability to change how our backend does pagination, since the user just uses opaque cursors.</li></ul><p>To see this in action, there&#x27;s an additional field in the example schema, called <code>friendsConnection</code>, that exposes all of these concepts. You can check it out in the example query. Try removing the <code>after</code> parameter to <code>friendsConnection</code> to see how the pagination will be affected. Also, try replacing the <code>edges</code> field with the helper <code>friends</code> field on the connection, which lets you get directly to the list of friends without the additional edge layer of indirection, when that&#x27;s appropriate for clients.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><h2><a class="anchor" name="connection-specification"></a>Connection Specification <a class="hash-link" href="#connection-specification">#</a></h2><p>To ensure a consistent implementation of this pattern, the Relay project has a formal <a href="https://facebook.github.io/relay/graphql/connections.htm" target="_blank" rel="nofollow noopener noreferrer">specification</a> you can follow for building GraphQL APIs which use a cursor based connection pattern.</p></div><a class="read-next" href="/learn/global-object-identification"><span class="read-next-continue">Continue Reading →</span><span class="read-next-title">Global Object Identification</span></a></div><div class="nav-docs"><div><h3>Learn</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">Introduction</a></li><li><a style="margin-left:0;" class="active" href="/learn/queries/">Queries and Mutations</a><ul><li><a href="/learn/queries/#fields">Fields</a></li><li><a href="/learn/queries/#arguments">Arguments</a></li><li><a href="/learn/queries/#aliases">Aliases</a></li><li><a href="/learn/queries/#fragments">Fragments</a></li><li><a href="/learn/queries/#operation-name">Operation Name</a></li><li><a href="/learn/queries/#variables">Variables</a></li><li><a href="/learn/queries/#directives">Directives</a></li><li><a href="/learn/queries/#mutations">Mutations</a></li><li><a href="/learn/queries/#inline-fragments">Inline Fragments</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">Schemas and Types</a><ul><li><a href="/learn/schema/#type-system">Type System</a></li><li><a href="/learn/schema/#type-language">Type Language</a></li><li><a href="/learn/schema/#object-types-and-fields">Object Types and Fields</a></li><li><a href="/learn/schema/#arguments">Arguments</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">The Query and Mutation Types</a></li><li><a href="/learn/schema/#scalar-types">Scalar Types</a></li><li><a href="/learn/schema/#enumeration-types">Enumeration Types</a></li><li><a href="/learn/schema/#lists-and-non-null">Lists and Non-Null</a></li><li><a href="/learn/schema/#interfaces">Interfaces</a></li><li><a href="/learn/schema/#union-types">Union Types</a></li><li><a href="/learn/schema/#input-types">Input Types</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">Validation</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">Execution</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">Introspection</a></li></ul></div><div><h3>Best Practices</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">Introduction</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">Thinking in Graphs</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">Serving over HTTP</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">Authorization</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">Pagination</a></li><li><a style="margin-left:0;" class="active" href="/learn/global-object-identification/">Global Object Identification</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">Caching</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home" aria-label="Homepage"></a><div><h5><a href="/learn/">Learn</a></h5><a href="/learn/">Introduction</a><a href="/learn/queries/">Query Language</a><a href="/learn/schema/">Type System</a><a href="/learn/execution/">Execution</a><a href="/learn/best-practices/">Best Practices</a></div><div><h5><a href="/code">Code</a></h5><a href="/code/#server-libraries">Servers</a><a href="/code/#graphql-clients">Clients</a><a href="/code/#tools">Tools</a></div><div><h5><a href="/community">Community</a></h5><a href="/community/upcoming-events/">Upcoming Events</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">Stack Overflow</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">Facebook Group</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">Twitter</a></div><div><h5>More</h5><a href="https://graphql.github.io/graphql-spec/" target="_blank" rel="noopener noreferrer">GraphQL Specification</a><a href="https://foundation.graphql.org/" target="_blank" rel="noopener noreferrer">GraphQL Foundation</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">GraphQL GitHub</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/BestPractice-Pagination.md" target="_blank" rel="noopener noreferrer">Edit this page ✎</a></div></section><section class="copyright">Copyright © 2020 The GraphQL Foundation. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page. Linux is a registered trademark of Linus Torvalds. <a href="http://www.linuxfoundation.org/privacy">Privacy Policy</a> and <a href="http://www.linuxfoundation.org/terms">Terms of Use</a>.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.e6796a1ba36b01034956.js"></script></body></html>